function git_ls_ignored () {
  git status --ignored -s | grep '^!!' | cut -c 4-
}

function git_ls_untracked () {
  git status "${1:-.}" -s | grep "^ *??" | cut -c 4-
}

function git_pristine {
  git reset $1 --hard && git clean -fX && git clean -fx && git clean -fd
}

function git_gc_all {
  git -c gc.reflogExpire=0 \
      -c gc.reflogExpireUnreachable=0 \
      -c gc.rerereresolved=0 \
      -c gc.rerereunresolved=0 \
      -c gc.pruneExpire=now \
      gc $@
}

function git_log_new () {
  c=$(git status -sb .git | grep 'ahead' | sed 's/.*\[ahead \([0-9]*\)\]/\1/')
  if [[ ! $c -eq "" ]]; then
    git log -n$((c+1)) "$@"
  else
    echo Current branch up-to-date with remote
  fi
}

function git_ref2hash () {
  git log -1 --format=format:"%H" ${1}
}

function git_checkout_modified {
  # git ls-files -m | xargs git checkout
  fs=$(git ls-files -m)
  if [[ ! -z "$fs" ]]; then
    printf \
      "This overwrites the following modified files. There is no way to get them back!\n\
$fs\n\
Are you sure? [Y/y]"
    read -p ""
    if [[ $REPLY =~ ^[Yy]$ ]]; then
      git ls-files -m -z | xargs -0 git checkout
    fi
  fi
}

function git_add_modified {
  git ls-files -m | xargs git add
}

function git_add_to_commit {
  if [ $# -eq 1 ]; then
    changes=$(git ls-files -m)
    if [[ -z "${changes// }" ]]; then
      oldcommit=$1
      git commit --fixup=${oldcommit}
      editor=$(git config --get core.editor)
      git config core.editor ":"
      (
        EDITOR=":"
        GIT_EDITOR=":"
        git rebase --interactive --autosquash ${oldcommit}^
      )
      git config core.editor '"$editor"'
    else
      printf \
        "You have modified files:\n\
$changes\n\
Rebase will not work! Stash or checkout modifications then try again.\n"
    fi
  elif [ $# -eq 0 ]; then
    git commit --amend --no-edit
  else
    echo Expected 0 or 1 arguments, got "$#":
    echo "$@"
  fi
}
