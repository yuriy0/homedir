function git_ls_ignored () {
  git status --ignored -s | grep '^!!' | cut -c 4-
}

function git_ls_status () {
  git status $2 -s | grep "^ *$1" | cut -c 4-
}

function git_ls_untracked () {
  git_ls_status "??" $1
}

function git_pristine {
  git reset $1 --hard && git clean -fX && git clean -fx && git clean -fd
}

function git_gc_all {
  git -c gc.reflogExpire=0 \
      -c gc.reflogExpireUnreachable=0 \
      -c gc.rerereresolved=0 \
      -c gc.rerereunresolved=0 \
      -c gc.pruneExpire=now \
      gc $@
}

function git_log_new () {
  c=$(git status -sb .git | grep 'ahead' | sed 's/.*\[ahead \([0-9]*\)\]/\1/')
  if [[ ! $c -eq "" ]]; then
    git log -n$((c+1)) "$@"
  else
    echo Current branch up-to-date with remote
  fi
}
# function git_log_new () {
#   s0=$(git status -sb .git | grep ahead)
#   if [ -z "$s0" ]; then
#     echo Current branch up-to-date with remote
#   else
#     s1=$(echo $s0 | sed 's/## \([^ ]*\)\.\.\.\([^ ]*\).*/\1 \2/')
#     read -ra s2 <<<"$s1"
#     s3=$(git_ref2hash ${s2[1]}^)
#     s4=$(git_ref2hash ${s2[0]})
#     echo git log $s3..$s4 $@
#   fi
# }

function git_ref2hash () {
  git log -1 --format=format:"%H" ${1}
}

